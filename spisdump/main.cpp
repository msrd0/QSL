#include "driver/driver.h"

#include <unistd.h>

#include <QCommandLineOption>
#include <QCommandLineParser>
#include <QCoreApplication>
#include <QMetaEnum>
#include <QMetaObject>

using namespace spis;
using namespace spis::driver;

int main(int argc, char **argv)
{
	QCoreApplication app(argc, argv);
	QCoreApplication::setApplicationName("SPISDump");
	QCoreApplication::setApplicationVersion(SPIS_VERSION_STR);
	
	QCommandLineParser parser;
	parser.setApplicationDescription("Dump SPIS for an existing database");
	QCommandLineOption helpOption(QStringList() << "?" << "help", "Display this help.");
	parser.addOption(helpOption);
	parser.addVersionOption();
	QCommandLineOption driverOption(QStringList() << "d" << "driver", "The driver used to connect to the database", "driver", "psql");
	parser.addOption(driverOption);
	QCommandLineOption hostOption(QStringList() << "h" << "host", "The host of the database server if required", "host");
	parser.addOption(hostOption);
	QCommandLineOption portOption(QStringList() << "p" << "port", "The port of the database server if required", "port");
	parser.addOption(portOption);
	QCommandLineOption userOption(QStringList() << "u" << "user", "The user used to connect to the database if required", "username");
	parser.addOption(userOption);
	QCommandLineOption passwordOption("password", "The password used to connect to the database if required", "password");
	parser.addOption(passwordOption);
	QCommandLineOption passwordAskOption("pw", "Ask for a password on the command line");
	parser.addOption(passwordAskOption);
	QCommandLineOption outputOption(QStringList() << "o" << "out", "The file to write the spis file (if - write to stdout)", "file", "-");
	parser.addOption(outputOption);
	parser.addPositionalArgument("name", "The name (or filename) of the database", "<db-name>");
	parser.process(app);
	if (parser.isSet(helpOption))
	{
		parser.showHelp(0);
		return 0;
	}
	QStringList args = parser.positionalArguments();
	if (args.size() != 1)
	{
		parser.showHelp(1);
		return 1;
	}
	
	FILE *out = stdout;
	if (parser.value(outputOption) != "-")
	{
		out = fopen(qPrintable(parser.value(outputOption)), "w");
		if (!out)
		{
			fprintf(stderr, "Failed to open %s: %s\n", qPrintable(parser.value(outputOption)), strerror(errno));
			return 1;
		}
	}
	
	Driver *driver = Driver::driver(parser.value(driverOption));
	if (!driver)
		return 1;
	Database *db = driver->newDatabase("utf8", false); // we just pass the defaults - there is no way to find out what's used atm
	Q_ASSERT(db);
	db->setName(args[0]);
	if (parser.isSet(hostOption))
		db->setHost(parser.value(hostOption));
	if (parser.isSet(portOption))
		db->setPort(parser.value(portOption).toInt());
	if (parser.isSet(userOption))
		db->setUser(parser.value(userOption));
	if (parser.isSet(passwordOption))
		db->setPassword(parser.value(passwordOption));
	if (parser.isSet(passwordAskOption))
		db->setPassword(getpass("Password:"));
	if (!db->connect())
	{
		fprintf(stderr, "Failed to connect to database\n");
		return 1;
	}
	
	QString name = args[0];
	if (name.contains('/'))
		name = name.mid(name.lastIndexOf('/')+1);
	if (name.contains('.'))
		name = name.mid(0, name.lastIndexOf('.'));
	
	fprintf(out, "##############################################################################\n"); // 78
	fprintf(out, "## This file was auto-generated by spisdump                                 ##\n");
	fprintf(out, "##                                                                          ##\n");
	fprintf(out, "## — Driver: %s\n", qPrintable(parser.value(driverOption)));
	if (parser.isSet(hostOption))
		fprintf(out, "## — Host: %s\n", qPrintable(parser.value(hostOption)));
	fprintf(out, "## — Name: %s\n", qPrintable(name));
	fprintf(out, "##                                                                          ##\n");
	fprintf(out, "## SPIS %d.%d.%d", SPIS_MAJOR, SPIS_MINOR, SPIS_PATCH);
	QByteArray rem = "                                                            ";
#if SPIS_MAJOR < 10
	rem += " ";
#endif
#if SPIS_MINOR < 10
	rem += " ";
#endif
#if SPIS_PATCH < 10
	rem += " ";
#endif
	fprintf(out, "%s##\n", rem.data());
	fprintf(out, "##############################################################################\n\n");
	
	fprintf(out, "database \"%s\"\n", qPrintable(name));
	fprintf(out, "# The charset that is used when creating the database. There is no guarantee\n");
	fprintf(out, "# that this encoding is used.\n");
	fprintf(out, "charset \"utf-8\"\n");
	fprintf(out, "# If uncommented, the varchar sql type will be used instead of char (the same\n");
	fprintf(out, "# applies to byte)\n");
	fprintf(out, "#usevar\n");
	// TODO charset and usevar
	for (auto tbl : db->tables())
	{
		fprintf(out, "\n");
		fprintf(out, "table \"%s\"\n", tbl.name().data());
		for (auto col : tbl.columns())
		{
			int minsize = col.minsize();
			if (minsize == -1)
				fprintf(out, "- %s \"%s\"", col.type(), col.name().data());
			else
			{
				const char* suffix = "";
				if (minsize%(int)1e9 == 0)
				{
					suffix = "G";
					minsize /= 1e9;
				}
				else if (minsize%(int)1e6 == 0)
				{
					suffix = "M";
					minsize /= 1e6;
				}
				else if (minsize%(int)1e3 == 0)
				{
					suffix = "K";
					minsize /= 1e3;
				}
				fprintf(out, "- %s(%d%s) \"%s\"", col.type(), minsize, suffix, col.name().data());
			}
			
			static const QMetaObject obj = SPIS::staticMetaObject;
			static const QMetaEnum cenum = obj.enumerator(obj.indexOfEnumerator("ColumnConstraint"));
			for (int i = 0; i < cenum.keyCount(); i++)
			{
				int val = cenum.value(i);
				if (val == SPIS::none)
					continue;
				if ((col.constraints() & val) == val)
					fprintf(out, " !%s", cenum.key(i));
			}
			
			fprintf(out, "\n");
		}
	}
	
	fclose(out);
	return 0;
}
